---
title: Tinkering with conditional code in SmartPy - sp.verify
chapter: Chapter 13
slug: chapter-13
editor:
  language: python
  startingCode: |
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self, manager_address):
            self.init(
                plant_manager = manager_address, 
                bullet_seed_count = 5, 
                record_zombie_kills = {
                    "simple_zombie": sp.nat(0), 
                    "boss_zombie": sp.nat(0), 
                }
                )

        @sp.entry_point
        def shoot_zombie(self, zombie_type):
            # Use sp.verify to check 
            # whether caller's address is equal 
            # to plant_manager's address
            
            self.data.bullet_seed_count -= 1
            self.data.record_zombie_kills[zombie_type] += 1

    @sp.add_test(name = "Testing entry functions only callable by plant manager")
    def test():
        scenario = sp.test_scenario()
        my_address = sp.address("tz1Syu3KacZ8cy4286a4vaCeoMtwqVKHkaoj")
        plant_test_contract =  Plant(manager_address = my_address)
        scenario += plant_test_contract
        # Use run method on both functions below and pass sender = my_address to it. 
        scenario += plant_test_contract.shoot_zombie("simple_zombie")
        scenario += plant_test_contract.shoot_zombie("boss_zombie")


  answer: |  
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self, manager_address):
            self.init(
                plant_manager = manager_address, 
                bullet_seed_count = 5,
                record_zombie_kills = {
                    "simple_zombie": sp.nat(0), 
                    "boss_zombie": sp.nat(0), 
                }
                )

        @sp.entry_point
        def shoot_zombie(self, zombie_type):
            # Use sp.verify to check 
            # whether caller's address is equal 
            # to plant_manager's address
            sp.verify(self.data.plant_manager == sp.sender, message = "Error: you are not the manager of this plant")
            self.data.bullet_seed_count -= 1
            self.data.record_zombie_kills[zombie_type] += 1

    @sp.add_test(name = "Testing entry functions only callable by plant manager")
    def test():
        scenario = sp.test_scenario()
        my_address = sp.address("tz1Syu3KacZ8cy4286a4vaCeoMtwqVKHkaoj")
        plant_test_contract =  Plant(manager_address = my_address)
        scenario += plant_test_contract
        # Use run method on both functions below and pass sender = my_address to it. 
        scenario += plant_test_contract.shoot_zombie("simple_zombie").run(sender = my_address)
        scenario += plant_test_contract.shoot_zombie("boss_zombie").run(sender = my_address)
---

### Intro: 
In this chapter we are going to learn about `verify` and specifically `sp.verify` which lets us write conditional code. 

`sp.verify` comes in handy to prevent an entry function from proceeding if certain conditions are not met. 

Examples of usecases where `sp.verify` can help: 

1. To check whether your account has enough money to transfer before initiating transfer. 
2. To add barriers to your entry functions so that they are only callable by the owner. 

In the later half of the chapter, we will use `sp.verify` to all of our entry point functions so that they are only callable by the `plant_manager`!



## Study Time: 


The syntax to use verify looks like this: 

```python
sp.verify(condition, message = "fail msg"â€‹)

## example: 
sp.verify(2 + 2 == 4)
sp.verify(4 > 5, message = "5 > 4")

```

Notes: 
1. `sp.verify` checks whether the `condition` evaluated to `True` and raises an error if it doesn't. The condition can be anything as long as the final outcome results in a boolean. 
2. An optional parameter message is raised if condition is not met.


To specifically check for equality conditions, you can use `sp.verify_equal`. 

```python
sp.verify_equal(v1, v2, message = "fail msg"â€‹)

## eg: 

sp.verify_equal(2 + 2, 4)

```

It serves the same purpose by checking equality between `v1 and v2. 


## #buidl-ing time:

#### New feature request!

Currently, entry functions of your `Plant` contract i.e it's abilities are callable by anybody in the world! 

In theory that means anybody can:
1. change your plantâ€™s name 
2. move the plant anywhere in the world 
3. as well as empty all your bullets without your permission!

Let us first learn to solve the third problem by allowing only `plant_manager`'s to shoot zombies. We have removed all the rest of the code that doesn't have anything to do with `shoot_zombie` function to help you focus. 

#### Step by step walkthrough: 

Let's start: 

1. In the `shoot_zombie` entry point function add `sp.verify`. 
2. In the `sp.verify`'s condition field: 
    * use `self.data.plant_manager` to access the address stored inside `plant_manager`. 
    * check it's equivalency with `sp.sender` - which SmartPy automatically populates with the address that called the current entry point. 
 
3. In the `sp.verify`'s `message` field: 
    * pass an error message on the lines of "Error: you are not the manager of this plant". 
    * This will be sent to users who are trying to be sneaky by calling our `Plant`'s `shoot_zombie` function! That will show them who is the boss! ðŸ˜Ž

#### Testing our code: 
Now since we have added that only the address stored inside `plant_manager` is able to call `shoot_zombie` entry point function, we would also need to modify `shoot_zombie` calls in our testing function: 

1. As you remember, we had stored our user account address in `my_address`
2. We will reference it when we are call our `shoot_zombie` function by using the `run` method. 
    * Syntax: `shoot_zombie("<zombie type>").run(sender = my_address)`
3. The above code tells SmartPy that we are calling `shoot_zombie` with `sender` value as `my_address`. 
4. SmartPy takes whatever address that was sent to `sender` and populates `sp.sender` in our `shoot_zombie`'s function defintion. 
    * Didn't we already mention that SmartPy is awesome! 


The implementation for all entry functions will remain the same and we leve that as an excersise to the user! 
