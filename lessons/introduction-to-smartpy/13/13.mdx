---
title: Tinkering with conditional code in SmartPy - sp.verify
chapter: Chapter 13
slug: chapter-13
editor:
  language: python
  startingCode: |
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self, manager_address):
            self.init(
                plant_manager = manager_address,

                bullet_seed_count = 5, 
                
                record_zombie_kills = {
                    "simple_zombie": sp.nat(0), 
                    "boss_zombie": sp.nat(0), 
                }
                )

        @sp.entry_point
        def shoot_zombie(self, zombie_type):
            # Use sp.verify to check 
            # whether caller's address is equal 
            # to plant_manager's address
     
            self.data.bullet_seed_count -= 1
            self.data.record_zombie_kills[zombie_type] += 1

    @sp.add_test(name = "Testing entry functions only callable by plant manager")
    def test():
        scenario = sp.test_scenario()
        
        my_address = sp.address("tz1Syu3KacZ8cy4286a4vaCeoMtwqVKHkaoj")
        
        plant_test_contract =  Plant(manager_address = my_address)
        
        scenario += plant_test_contract
        
        # Use run method on both functions below and pass sender = my_address to it. 
        scenario += plant_test_contract.shoot_zombie("simple_zombie")
        scenario += plant_test_contract.shoot_zombie("boss_zombie")


  answer: |  
    import smartpy as sp

    class Plant(sp.Contract):
        def __init__(self, manager_address):
            self.init(
                plant_manager = manager_address, 
                
                bullet_seed_count = 5,
                
                record_zombie_kills = {
                    "simple_zombie": sp.nat(0), 
                    "boss_zombie": sp.nat(0), 
                }
                )

        @sp.entry_point
        def shoot_zombie(self, zombie_type):
            # Use sp.verify to check 
            # whether caller's address is equal 
            # to plant_manager's address
            sp.verify(self.data.plant_manager == sp.sender, message = "Error: non manager call")
            
            self.data.bullet_seed_count -= 1
            self.data.record_zombie_kills[zombie_type] += 1

    @sp.add_test(name = "Testing entry functions only callable by plant manager")
    def test():
        scenario = sp.test_scenario()
        
        my_address = sp.address("tz1Syu3KacZ8cy4286a4vaCeoMtwqVKHkaoj")
        
        plant_test_contract =  Plant(manager_address = my_address)
        
        scenario += plant_test_contract
        
        # Use run method on both functions below and pass sender = my_address to it. 
        scenario += plant_test_contract.shoot_zombie("simple_zombie").run(sender = my_address)
        scenario += plant_test_contract.shoot_zombie("boss_zombie").run(sender = my_address)
---

### Intro: 
In this chapter we are going to learn about `verify` and specifically `sp.verify` which lets us write conditional code. 

`sp.verify` comes in handy to prevent an entry function from proceeding if certain conditions are not met. 

Examples of usecases where `sp.verify` can help: 

1. To check whether your account has enough money to transfer before initiating transfer. 
2. To add barriers to your entry functions so that they are only callable by the owner. 

In the later half of the chapter, we will use `sp.verify` to all of our entry point functions so that they are only callable by the `plant_manager`!



## Study Time: 


The syntax to use verify looks like this: 

```python
sp.verify(condition, message = "fail msg"‚Äã)

## example: 
sp.verify(2 + 2 == 4)
sp.verify(4 > 5, message = "5 > 4")

```

Notes:

1. `sp.verify` checks whether the `condition` evaluated to <span class="string-highlight">True</span> and raises an error if it doesn't. The condition can be anything as long as the final outcome results in a boolean. 
2. An optional parameter message is raised if condition is not met.


To specifically check for equality conditions, you can use `sp.verify_equal`. 

```python
sp.verify_equal(v1, v2, message = "fail msg"‚Äã)

## eg: 

sp.verify_equal(2 + 2, 4)

```

It serves the same purpose by checking equality between <span class="string-highlight">v1</span> and <span class="string-highlight">v2</span>


## #buidl-ing time:

#### New feature request!

Currently, entry functions of your `Plant` contract i.e it's abilities are callable by anybody in the world! 

In theory that means anybody can:

1. change your plant‚Äôs name 
2. move the plant anywhere in the world 
3. as well as empty all your bullets without your permission!


Let us first learn to solve the third problem by allowing only `plant_manager`'s to shoot zombies. 

#### Step by step walkthrough: 

Let's start: 

1. In the `shoot_zombie` entry point function add `sp.verify`. 
2. In the `sp.verify`'s condition field: 
    * use `self.data.plant_manager` to access the address stored inside `plant_manager`. 
    * check it's equivalency with `sp.sender`:
       * SmartPy automatically populates `sp.address` with the address that called the current entry point.
       * **This is an important concept to keep in mind as `sp.sender` is very useful when working with entry point functions.**
 
3. In the `sp.verify`'s `message` field: 
    * pass an error message on the lines of <span class="string-highlight">"Error: non manager call".</span>
    * This will be sent to users who are trying to be sneaky by calling our `Plant`'s `shoot_zombie` function! 

That will show them who is the boss! üòé

![Alt Text](https://media.giphy.com/media/tRl9evJaEURRm/giphy.gif)

#### Testing our code: 

Now since we have added that only the address stored inside `plant_manager` is able to call `shoot_zombie` entry point function, we would also need to modify `shoot_zombie` calls in our testing function: 

1. As you remember, we had stored our user account address in `my_address`
2. We will reference it when we are call our `shoot_zombie` function by using the `run` method. 
    * Syntax: `shoot_zombie("<zombie type>").run(sender = my_address)`
    * The above code tells SmartPy that we are calling `shoot_zombie` with `sender` value as `my_address`. 
4. SmartPy takes whatever address that was sent to `sender` and populates `sp.sender` in our `shoot_zombie`'s function defintion. 
    * Didn't we already mention that SmartPy is awesome! 


The implementation for all entry functions will remain the same and we leve that as an exercise to the user! 


<br />

When you‚Äôre finished:

1. Click on ‚ÄúCheck‚Äù to check your submission with the correct answer.
2. Click on ‚ÄúShow Answer‚Äù in case you get stuck.


You can also tinker around with the final code on [SmartPy‚Äôs online IDE](https://smartpy.io/demo/index.html?code=eJydVO@L1DAQ_d6_YqgfbHEtnp5yLCwIhyAcguCPD4qENJ29jZsmvUx6S0_835203d12XVTMt0nfvJm8N1NdN84HoFr60HQgCahJEmUkEbw30oaMmuLa2eClCvkyAT4VrkEIbXUQIiM06wXU0spb9EJWlUeiERhP_F5EbHa4iqeJ3GJMg9UpwSKZocvWGAyCECuhXGsDZ7xcwAwzCzwq5yvx4OpSo9hqY4hTfsww8aSk68bgCEyX_PrCypA9y0_Ye3DpiP4O_TmL8uElrxmNrGInGqdtOOhIG@fCyDlqOTYdugYnOj6CT4Sx5j16ve4gOFAbVFuYIHYbDBuWU0mWyz8mGNUETYB3rTRTMBPMTDjCj97tq_WdFZUMsjgxbhVBhLZCz1PAyXzNSqdvvHd@CdbZvbV9V2mewHw0etLf_X26goszwDO@fp3o9Q2exLwkqs2PEQEpZFbWfUsfOdD2FnobYN1aFbSzBM6arm9Olgah7AZZ9m1zx9Gnnmm0gxRa6bWD_vHxi9hfZXlymMW620_zAByDLA0PFx@69sWNVF@uVHf5_OqVvLyX1@jehd3d55u3W@m@pxOiQfK@jho3kRnH9TxZnLhKh7oTjkPPLNAZviNwmDPfsm88TK5ieaB0YTMRrETjdiBtBU38TQzuzwrH4dKh@KfSxWwFThYyL7iT7EyF_D@op@v7B@Jf8HKX5A--). Try running the test by clicking on the ‚ñ∂Ô∏è button!

